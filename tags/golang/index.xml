<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on 玖月的博客</title>
    <link>https://gangsusu.github.io/tags/golang/</link>
    <description>Recent content in golang on 玖月的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 08 Oct 2021 09:00:00 +0800</lastBuildDate><atom:link href="https://gangsusu.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go数据类型之map</title>
      <link>https://gangsusu.github.io/post/2021-09-30-go-map/</link>
      <pubDate>Fri, 08 Oct 2021 09:00:00 +0800</pubDate>
      
      <guid>https://gangsusu.github.io/post/2021-09-30-go-map/</guid>
      <description>map的基本介绍 map是go中一种很重要的数据类型，是一种无序的键值对集合。它有一些独特的特点。
遍历时候是无序的 map是一种集合，我们可以来迭代它。但是迭代出来的结果是无序的，它是用hash表来实现的。 按照一些资料显示，map的无序是有意为之，大佬不希望使用者依赖key的排序，来定位value。可自行迭代来验证迭代结果是否是无序的。
并发不安全 map是并发不安全的，不注意这个点，很容易造成bug，如下面的演示，启动了3个线程来调用write方法，下面的代码会报错，提示goroutine running on other thread; stack unavailable
并发不安全的演示 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func write(m map[string]int) { for i := 0; i &amp;lt; 100000; i++ { m[&amp;#34;num&amp;#34;] = i } } func main() { map01 := map[string]int{&amp;#34;num&amp;#34;: 0} go write(map01) go write(map01) go write(map01) time.Sleep(1 * time.Second) fmt.Println(map01) } 使用加锁来保证并发安全 简单处理，可以在执行每个操作的时候加锁，代码如下：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) var Lock sync.RWMutex func write(m map[string]int) { for i := 0; i &amp;lt; 100000; i++ { Lock.</description>
    </item>
    
    <item>
      <title>go中的深拷贝和浅拷贝</title>
      <link>https://gangsusu.github.io/post/2021-09-28-go-copy/</link>
      <pubDate>Tue, 28 Sep 2021 09:00:00 +0800</pubDate>
      
      <guid>https://gangsusu.github.io/post/2021-09-28-go-copy/</guid>
      <description>go中的数据类型 在go中，数据类型有很多，int、string、bool、array、slice、map、struct、channel、interface、function等。
代码验证  数组在php中是非常重要的数据类型，在php中是深拷贝，我们先看看go中的数组  array01 := [3]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;} array02 := array01 array01[1] = &amp;#34;B&amp;#34; fmt.Println(array01) // [a B c] 	fmt.Println(array02) // [a b c] go中的数组也是深拷贝。
我们看一看切片slice  slice01 := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;} slice02 := slice01 slice01[1] = &amp;#34;B&amp;#34; fmt.Println(slice01) // [a B c] 	fmt.Println(slice02) // [a B c] 我们可以看到，slice是浅拷贝。
我们可以使用一个copy函数来对slice进行深拷贝  slice03 := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;} slice04 := make([]string, 3, 3) copy(slice04, slice03) slice03[1] = &amp;#34;B&amp;#34; fmt.</description>
    </item>
    
  </channel>
</rss>
